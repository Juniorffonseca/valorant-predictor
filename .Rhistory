layout(xaxis = list(title = 'Porcentagem'), yaxis = list(title = 'Ganhador'),
legend = list(title = 'Ganhador', font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = 'line', x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = 'gray', width = 2))))
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(valorant)
# Instalar o pacote whatsappR do GitHub
devtools::install_github("jbello/whatsappR")
# Carregar o pacote
library(whatsappR)
# Enviar uma mensagem para um número de telefone
whatsappr_send("+55XXXXXXXXXX", "Olá, esta é uma mensagem enviada pelo R!")
# Instalar o pacote whatsappR do GitHub
devtools::install_github("jbello/whatsappR")
# Instalar o pacote whatsappR do GitHub
devtools::install_github("JBruber/whatsappR")
# Instalar o pacote whatsappR do GitHub
devtools::install_github("JBruber/rwhatsapp")
# Instalar o pacote whatsappR do GitHub
devtools::install_github("JBGruber/rwhatsapp")
# Carregar o pacote
library(rwhatsapp)
# Iniciar uma sessão do WhatsApp Web
whatsappr_setup()
# Instalar o pacote whatsappR do GitHub
devtools::install_github("JBGruber/rwhatsapp")
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(valorant)
# Matriz de confusão ---------------------------------------------------------------------------------------
jogos <- read.csv2('csv/partidas_teste.csv') %>% dplyr::select(-X)
set.seed(s-1) #10679
data_split <- initial_split(jogos, prop = 0.7, strata = 'ganhador')
training_data <- training(data_split)
test_data <- testing(data_split)
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
test_data$ganhador <- as.factor(test_data$ganhador)
training_data$ganhador <- as.factor(training_data$ganhador)
# Carregando modelo e obtendo os resultados
load('prototipo_rede_neural.rda')
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5, 1, 0)
nn2 <- as.factor(nn2)
x <- caret::confusionMatrix(nn2, test_data$ganhador)
F1 <- x$byClass['F1']
x <- as.data.frame(x$table)
predictVstest <- cbind(test_data, Predict$net.result)
# Matriz de confusão ---------------------------------------------------------------------------------------
jogos <- read.csv2('csv/partidas_teste.csv') %>% dplyr::select(-X)
s <- 10679
set.seed(s-1) #10679
data_split <- initial_split(jogos, prop = 0.7, strata = 'ganhador')
training_data <- training(data_split)
test_data <- testing(data_split)
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
test_data$ganhador <- as.factor(test_data$ganhador)
training_data$ganhador <- as.factor(training_data$ganhador)
# Carregando modelo e obtendo os resultados
load('prototipo_rede_neural.rda')
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5, 1, 0)
nn2 <- as.factor(nn2)
x <- caret::confusionMatrix(nn2, test_data$ganhador)
F1 <- x$byClass['F1']
x <- as.data.frame(x$table)
predictVstest <- cbind(test_data, Predict$net.result)
names(predictVstest)[32] <- 'previsao'
# Plot
ggplot(data = x, mapping = aes(x = Reference, y = Prediction)) +
geom_tile(aes(fill = Freq), colour = 'white') +
geom_text(aes(label = sprintf('%1.0f', Freq)), vjust = 1) +
scale_fill_gradient(low = 'white', high = 'green') +
theme_bw() + theme(legend.position = 'none')
#Log Loss
logLoss(actual = test_data$ganhador, predicted = Predict$net.result)
#Plot distribuição
plot_ly(data = predictVstest, x = ~previsao, y = ~ganhador,
color = ~factor(ganhador), colors = c('red', 'green'), type = 'scatter',
mode = 'markers', marker = list(size = 4)) %>%
layout(xaxis = list(title = 'Porcentagem'), yaxis = list(title = 'Ganhador'),
legend = list(title = 'Ganhador', font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = 'line', x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = 'gray', width = 2))))
ggplotly(
jogos %>%
ggplot() +
geom_point(aes(x = time2R, y = ganhador), color = 'orange', size = 2) +
geom_point(aes(x = time1R, y = ganhador), color = 'blue', size = 1) +
labs(x = 'Estatística',
y = 'Ganhador') +
theme_bw()
)
View(x)
# Plot
ggplot(data = x, mapping = aes(x = Reference, y = Prediction)) +
geom_tile(aes(fill = Freq), colour = 'white') +
geom_text(aes(label = sprintf('%1.0f', Freq)), vjust = 1) +
scale_fill_gradient(low = 'white', high = 'green') +
theme_bw() + theme(legend.position = 'none')
x <- caret::confusionMatrix(nn2, test_data$ganhador)
x
library(ROCR)
# Curva ROC
predicoes <- ROCR::prediction(predictions = predictVstest$previsao,
labels = as.factor(predictVstest$ganhador))
dados_curva_roc <- ROCR::performance(predicoes, measure = 'sens')
View(dados_curva_roc)
sensitividade <- (perfomance(predicoes, measure = 'sens'))@y.values[[1]]
sensitividade <- (performance(predicoes, measure = 'sens'))@y.values[[1]]
especificidade <- (performance(predicoes, measure = 'sens'))@y.values[[1]]
# Extraindo os CUTOFFS:
cutoffs <- dados_curva_roc@x.values[[1]]
dados_plotagem <- cbind(cutoffs, especificidade, sensitividade)
dados_plotagem <- cbind.data.frame(cutoffs, especificidade, sensitividade)
dados_plotagem %>%
kable() %>%
kable_stylng(bootstrap_options = 'striped',
full_width = F,
font_size = 22)
dados_plotagem %>%
kable() %>%
kable_styling(bootstrap_options = 'striped',
full_width = F,
font_size = 22)
library(kableExtra)
dados_plotagem %>%
kable() %>%
kable_styling(bootstrap_options = 'striped',
full_width = F,
font_size = 22)
ggplotly(dados_plotagem %>%
ggplot(aes(x = cutoffs, y = especificidade)) +
geom_line(aes(color = "Especificidade"),
size = 1) +
geom_point(color = "#95D840FF",
size = 1.9) +
geom_line(aes(x = cutoffs, y = sensitividade, color = "Sensitividade"),
size = 1) +
geom_point(aes(x = cutoffs, y = sensitividade),
color = "#440154FF",
size = 1.9) +
labs(x = "Cutoff",
y = "Sensitividade/Especificidade") +
scale_color_manual("Legenda:",
values = c("#95D840FF", "#440154FF")) +
theme_bw())
especificidade <- (performance(predicoes, measure = 'spec'))@y.values[[1]]
# Extraindo os CUTOFFS:
cutoffs <- dados_curva_roc@x.values[[1]]
dados_plotagem <- cbind.data.frame(cutoffs, especificidade, sensitividade)
dados_plotagem %>%
kable() %>%
kable_styling(bootstrap_options = 'striped',
full_width = F,
font_size = 22)
ggplotly(dados_plotagem %>%
ggplot(aes(x = cutoffs, y = especificidade)) +
geom_line(aes(color = "Especificidade"),
size = 1) +
geom_point(color = "#95D840FF",
size = 1.9) +
geom_line(aes(x = cutoffs, y = sensitividade, color = "Sensitividade"),
size = 1) +
geom_point(aes(x = cutoffs, y = sensitividade),
color = "#440154FF",
size = 1.9) +
labs(x = "Cutoff",
y = "Sensitividade/Especificidade") +
scale_color_manual("Legenda:",
values = c("#95D840FF", "#440154FF")) +
theme_bw())
ROC <- roc(response = predictVstest$ganhador,
predictor = predictVstest$previsao)
ROC <- roc(response = predictVstest$ganhador,
predictor = as.factor(predictVstest$previsao))
ROC <- roc(response = as.factor(predictVstest$ganhador),
predictor = predictVstest$previsao)
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = "grey40", size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = "1 - Especificidade",
y = "Sensitividade",
title = paste("Área abaixo da curva:",
round(ROC$auc, 4),
"|",
"Coeficiente de Gini:",
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = "black", fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
# Carregando modelo e obtendo os resultados
load('prototipo_rede_neural.rda')
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5505, 1, 0)
nn2 <- as.factor(nn2)
x <- caret::confusionMatrix(nn2, test_data$ganhador)
F1 <- x$byClass['F1']
x <- as.data.frame(x$table)
predictVstest <- cbind(test_data, Predict$net.result)
names(predictVstest)[32] <- 'previsao'
# Curva ROC
predicoes <- ROCR::prediction(predictions = predictVstest$previsao,
labels = as.factor(predictVstest$ganhador))
dados_curva_roc <- ROCR::performance(predicoes, measure = 'sens')
sensitividade <- (performance(predicoes, measure = 'sens'))@y.values[[1]]
especificidade <- (performance(predicoes, measure = 'spec'))@y.values[[1]]
# Extraindo os CUTOFFS:
cutoffs <- dados_curva_roc@x.values[[1]]
dados_plotagem <- cbind.data.frame(cutoffs, especificidade, sensitividade)
dados_plotagem %>%
kable() %>%
kable_styling(bootstrap_options = 'striped',
full_width = F,
font_size = 22)
ggplotly(dados_plotagem %>%
ggplot(aes(x = cutoffs, y = especificidade)) +
geom_line(aes(color = "Especificidade"),
size = 1) +
geom_point(color = "#95D840FF",
size = 1.9) +
geom_line(aes(x = cutoffs, y = sensitividade, color = "Sensitividade"),
size = 1) +
geom_point(aes(x = cutoffs, y = sensitividade),
color = "#440154FF",
size = 1.9) +
labs(x = "Cutoff",
y = "Sensitividade/Especificidade") +
scale_color_manual("Legenda:",
values = c("#95D840FF", "#440154FF")) +
theme_bw())
ROC <- roc(response = as.factor(predictVstest$ganhador),
predictor = predictVstest$previsao)
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = "grey40", size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = "1 - Especificidade",
y = "Sensitividade",
title = paste("Área abaixo da curva:",
round(ROC$auc, 4),
"|",
"Coeficiente de Gini:",
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = "black", fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
# Plot
ggplot(data = x, mapping = aes(x = Reference, y = Prediction)) +
geom_tile(aes(fill = Freq), colour = 'white') +
geom_text(aes(label = sprintf('%1.0f', Freq)), vjust = 1) +
scale_fill_gradient(low = 'white', high = 'green') +
theme_bw() + theme(legend.position = 'none')
x
x <- caret::confusionMatrix(nn2, test_data$ganhador)
x
# Carregando modelo e obtendo os resultados
load('prototipo_rede_neural.rda')
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5, 1, 0)
nn2 <- as.factor(nn2)
x <- caret::confusionMatrix(nn2, test_data$ganhador)
F1 <- x$byClass['F1']
x <- as.data.frame(x$table)
predictVstest <- cbind(test_data, Predict$net.result)
names(predictVstest)[32] <- 'previsao'
# Curva ROC
predicoes <- ROCR::prediction(predictions = predictVstest$previsao,
labels = as.factor(predictVstest$ganhador))
dados_curva_roc <- ROCR::performance(predicoes, measure = 'sens')
sensitividade <- (performance(predicoes, measure = 'sens'))@y.values[[1]]
especificidade <- (performance(predicoes, measure = 'spec'))@y.values[[1]]
# Extraindo os CUTOFFS:
cutoffs <- dados_curva_roc@x.values[[1]]
dados_plotagem <- cbind.data.frame(cutoffs, especificidade, sensitividade)
dados_plotagem %>%
kable() %>%
kable_styling(bootstrap_options = 'striped',
full_width = F,
font_size = 22)
ggplotly(dados_plotagem %>%
ggplot(aes(x = cutoffs, y = especificidade)) +
geom_line(aes(color = "Especificidade"),
size = 1) +
geom_point(color = "#95D840FF",
size = 1.9) +
geom_line(aes(x = cutoffs, y = sensitividade, color = "Sensitividade"),
size = 1) +
geom_point(aes(x = cutoffs, y = sensitividade),
color = "#440154FF",
size = 1.9) +
labs(x = "Cutoff",
y = "Sensitividade/Especificidade") +
scale_color_manual("Legenda:",
values = c("#95D840FF", "#440154FF")) +
theme_bw())
ROC <- roc(response = as.factor(predictVstest$ganhador),
predictor = predictVstest$previsao)
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = "grey40", size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = "1 - Especificidade",
y = "Sensitividade",
title = paste("Área abaixo da curva:",
round(ROC$auc, 4),
"|",
"Coeficiente de Gini:",
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = "black", fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
# Plot
ggplot(data = x, mapping = aes(x = Reference, y = Prediction)) +
geom_tile(aes(fill = Freq), colour = 'white') +
geom_text(aes(label = sprintf('%1.0f', Freq)), vjust = 1) +
scale_fill_gradient(low = 'white', high = 'green') +
theme_bw() + theme(legend.position = 'none')
#Log Loss
logLoss(actual = test_data$ganhador, predicted = Predict$net.result)
#Plot distribuição
plot_ly(data = predictVstest, x = ~previsao, y = ~ganhador,
color = ~factor(ganhador), colors = c('red', 'green'), type = 'scatter',
mode = 'markers', marker = list(size = 4)) %>%
layout(xaxis = list(title = 'Porcentagem'), yaxis = list(title = 'Ganhador'),
legend = list(title = 'Ganhador', font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = 'line', x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = 'gray', width = 2))))
ggplotly(
jogos %>%
ggplot() +
geom_point(aes(x = time2R, y = ganhador), color = 'orange', size = 2) +
geom_point(aes(x = time1R, y = ganhador), color = 'blue', size = 1) +
labs(x = 'Estatística',
y = 'Ganhador') +
theme_bw()
)
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = "grey40", size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = "1 - Especificidade",
y = "Sensitividade",
title = paste("Área abaixo da curva:",
round(ROC$auc, 4),
"|",
"Coeficiente de Gini:",
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = "black", fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
# Carregando modelo e obtendo os resultados
load('prototipo_rede_neural.rda')
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5, 1, 0)
nn2 <- as.factor(nn2)
x <- caret::confusionMatrix(nn2, test_data$ganhador)
x
F1 <- x$byClass['F1']
x <- as.data.frame(x$table)
predictVstest <- cbind(test_data, Predict$net.result)
names(predictVstest)[32] <- 'previsao'
# Curva ROC
ROC <- roc(response = as.factor(predictVstest$ganhador),
predictor = predictVstest$previsao)
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = 'grey40', size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = '1 - Especificidade',
y = 'Sensitividade',
title = paste('Área abaixo da curva:',
round(ROC$auc, 4),
'|',
'Coeficiente de Gini:',
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = 'black', fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
# Plot
ggplot(data = x, mapping = aes(x = Reference, y = Prediction)) +
geom_tile(aes(fill = Freq), colour = 'white') +
geom_text(aes(label = sprintf('%1.0f', Freq)), vjust = 1) +
scale_fill_gradient(low = 'white', high = 'green') +
theme_bw() + theme(legend.position = 'none')
#Log Loss
logLoss(actual = test_data$ganhador, predicted = Predict$net.result)
#Plot distribuição
plot_ly(data = predictVstest, x = ~previsao, y = ~ganhador,
color = ~factor(ganhador), colors = c('red', 'green'), type = 'scatter',
mode = 'markers', marker = list(size = 4)) %>%
layout(xaxis = list(title = 'Porcentagem'), yaxis = list(title = 'Ganhador'),
legend = list(title = 'Ganhador', font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = 'line', x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = 'gray', width = 2))))
ggplotly(
jogos %>%
ggplot() +
geom_point(aes(x = time2R, y = ganhador), color = 'orange', size = 2) +
geom_point(aes(x = time1R, y = ganhador), color = 'blue', size = 1) +
labs(x = 'Estatística',
y = 'Ganhador') +
theme_bw()
)
# Fazer previsões nos dados de treinamento e teste usando a rede neural treinada
train_preds <- predict(n, training_data)
test_preds <- predict(n, test_data)
train_preds <- ifelse(train_preds > 0.5, 1, 0)
test_preds <- ifelse(test_preds > 0.5, 1, 0)
# Calcular a precisão da rede neural nos conjuntos de treinamento e teste
train_acc <- mean(train_preds == training_data$ganhador)
test_acc <- mean(test_preds == test_data$ganhador)
# Exibir a precisão nos conjuntos de treinamento e teste
cat('Precisão nos dados de treinamento:', train_acc, '\n')
cat('Precisão nos dados de teste:', test_acc, '\n')
# Verificar se há overfitting comparando a precisão nos conjuntos de treinamento e teste
if(test_acc < train_acc){
cat('A precisão nos dados de teste é menor do que a precisão nos dados de treinamento, o que pode indicar overfitting.\n')
} else {
cat('Não há evidência de overfitting.\n')
}
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = 'grey40', size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = '1 - Especificidade',
y = 'Sensitividade',
title = paste('Área abaixo da curva:',
round(ROC$auc, 4),
'|',
'Coeficiente de Gini:',
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = 'black', fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
