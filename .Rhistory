training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
}
s <- 1
while ( i < 0.72) {
acharseed(s)
s <- s + 1
}
while ( i < 0.79) {
acharseed(s)
s <- s + 1
}
s <- 1
while ( i < 0.76) {
acharseed(s)
s <- s + 1
}
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
# Atualizando a seed para achar a melhor neuralnetwork -------------------------------------------------------
set.seed(398) #4 #59
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.73) {
acharnn()
}
while ( i < 0.83) {
acharnn()
}
while ( i < 0.78) {
acharnn()
}
while ( i < 0.70) {
acharnn()
}
while ( i < 0.79) {
acharnn()
}
jogos <- read.csv2('csv/partidas_5.csv') %>% dplyr::select(-X)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
s <- 1
while ( i < 0.76) {
acharseed(s)
s <- s + 1
}
s <- 1
while ( i < 0.78) {
acharseed(s)
s <- s + 1
}
# Atualizando a seed para achar a melhor neuralnetwork -------------------------------------------------------
set.seed(386) #4 #59
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.83) {
acharnn()
}
while ( i < 0.80) {
acharnn()
}
#save(n, file ='model_nnet.rda')
#save(n, file ='model_2_nnet.rda') #2991
#save(n, file ='model_3_nnet.rda')
save(n, file ='model_4_nnet.rda') #possivelmente usarei esse para tentar prever o lockin sp
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
nn2 <- as.factor(nn2)
x <- confusionMatrix(nn2, test_data$ganhador)
x <- as.data.frame(x$table)
# Plot
ggplot(data = x, mapping = aes(x = Reference, y = Prediction)) +
geom_tile(aes(fill = Freq), colour = 'white') +
geom_text(aes(label = sprintf('%1.0f', Freq)), vjust = 1) +
scale_fill_gradient(low = 'white', high = 'green') +
theme_bw() + theme(legend.position = 'none')
get_Ganhadores(x)
get_Ganhadores('heuiqwe')
get_Ganhadores('https://www.vlr.gg/167348/koi-vs-nrg-esports-champions-tour-2023-lock-in-s-o-paulo-alpha-ro16')
medias_Times('https://www.vlr.gg/167348/koi-vs-nrg-esports-champions-tour-2023-lock-in-s-o-paulo-alpha-ro16')
testandoo <- medias_Times('https://www.vlr.gg/167348/koi-vs-nrg-esports-champions-tour-2023-lock-in-s-o-paulo-alpha-ro16')
#' Médias dos times.
#' Função que calcula as médias de cada estatística para os dois times de uma determinada partida.
#' Para utilizar: medias_Times()
#' @export
# Função medias_times -------------------------------------------------------------------------------------
medias_Times <- function (url_partida){
tryCatch(
{
# Pegando os dados no link da partida -------------------------------------------------------------------
links_jogadores <- read_html(url_partida, resultado) %>%
html_nodes('td.mod-player a') %>%
html_attr('href')
# Separando os nomes dos jogadores de cada time em 2 arrays
timeA <- links_jogadores[1:5]
timeB <- links_jogadores[6:10]
# Criando os links usando os nomes dos jogadores para ficar entre '...vlr.gg' e '/?timespan...'
n <- 1
for (i in timeA){
timeA[n] <- paste('https://www.vlr.gg', '/?timespan=all', sep = i)
n = n + 1
}
n <- 1
for(i in timeB){
timeB[n] <- paste('https://www.vlr.gg', '/?timespan=all', sep = i)
n = n + 1
}
timeA_medias <- list()
timeB_medias <- list()
for (i in timeA){
timeA_medias[[length(timeA_medias)+1]] <- medias_Jogadores(i)
}
for (i in timeB){
timeB_medias[[length(timeB_medias)+1]] <- medias_Jogadores(i)
}
timeA_medias <- timeA_medias %>% map_df(as_tibble)
timeB_medias <- timeB_medias %>% map_df(as_tibble)
timeA_medias <- dplyr::select(timeA_medias, -Use)
timeB_medias <- dplyr::select(timeB_medias, -Use)
partida <- cbind(timeA_medias, timeB_medias)
colnames(partida) <- c('time1R', 'time1ACS', 'time1KAST', 'time1KD', 'time1ADR',
'time2R', 'time2ACS', 'time2KAST', 'time2KD', 'time2ADR')
partida <- select(partida, 'time1R', 'time2R', 'time1ACS', 'time2ACS', 'time1KAST', 'time2KAST', 'time1KD', 'time2KD',
'time1ADR', 'time2ADR')
partida <- as.data.frame(t(colMeans(partida)))
if(resultado = TRUE){
#' Médias dos times.
#' Função que calcula as médias de cada estatística para os dois times de uma determinada partida.
#' Para utilizar: medias_Times()
#' @export
# Função medias_times -------------------------------------------------------------------------------------
medias_Times <- function (url_partida){
tryCatch(
{
# Pegando os dados no link da partida -------------------------------------------------------------------
links_jogadores <- read_html(url_partida, resultado) %>%
html_nodes('td.mod-player a') %>%
html_attr('href')
# Separando os nomes dos jogadores de cada time em 2 arrays
timeA <- links_jogadores[1:5]
timeB <- links_jogadores[6:10]
# Criando os links usando os nomes dos jogadores para ficar entre '...vlr.gg' e '/?timespan...'
n <- 1
for (i in timeA){
timeA[n] <- paste('https://www.vlr.gg', '/?timespan=all', sep = i)
n = n + 1
}
n <- 1
for(i in timeB){
timeB[n] <- paste('https://www.vlr.gg', '/?timespan=all', sep = i)
n = n + 1
}
timeA_medias <- list()
timeB_medias <- list()
for (i in timeA){
timeA_medias[[length(timeA_medias)+1]] <- medias_Jogadores(i)
}
for (i in timeB){
timeB_medias[[length(timeB_medias)+1]] <- medias_Jogadores(i)
}
timeA_medias <- timeA_medias %>% map_df(as_tibble)
timeB_medias <- timeB_medias %>% map_df(as_tibble)
timeA_medias <- dplyr::select(timeA_medias, -Use)
timeB_medias <- dplyr::select(timeB_medias, -Use)
partida <- cbind(timeA_medias, timeB_medias)
colnames(partida) <- c('time1R', 'time1ACS', 'time1KAST', 'time1KD', 'time1ADR',
'time2R', 'time2ACS', 'time2KAST', 'time2KD', 'time2ADR')
partida <- select(partida, 'time1R', 'time2R', 'time1ACS', 'time2ACS', 'time1KAST', 'time2KAST', 'time1KD', 'time2KD',
'time1ADR', 'time2ADR')
partida <- as.data.frame(t(colMeans(partida)))
if(resultado == TRUE){
ganhador <- get_Ganhadores(url_partida)
partida <- cbind(partida, ganhador)
}
else(){}
#' Médias dos times.
#' Função que calcula as médias de cada estatística para os dois times de uma determinada partida.
#' Para utilizar: medias_Times()
#' @export
# Função medias_times -------------------------------------------------------------------------------------
medias_Times <- function (url_partida){
tryCatch(
{
# Pegando os dados no link da partida -------------------------------------------------------------------
links_jogadores <- read_html(url_partida, resultado) %>%
html_nodes('td.mod-player a') %>%
html_attr('href')
# Separando os nomes dos jogadores de cada time em 2 arrays
timeA <- links_jogadores[1:5]
timeB <- links_jogadores[6:10]
# Criando os links usando os nomes dos jogadores para ficar entre '...vlr.gg' e '/?timespan...'
n <- 1
for (i in timeA){
timeA[n] <- paste('https://www.vlr.gg', '/?timespan=all', sep = i)
n = n + 1
}
n <- 1
for(i in timeB){
timeB[n] <- paste('https://www.vlr.gg', '/?timespan=all', sep = i)
n = n + 1
}
timeA_medias <- list()
timeB_medias <- list()
for (i in timeA){
timeA_medias[[length(timeA_medias)+1]] <- medias_Jogadores(i)
}
for (i in timeB){
timeB_medias[[length(timeB_medias)+1]] <- medias_Jogadores(i)
}
timeA_medias <- timeA_medias %>% map_df(as_tibble)
timeB_medias <- timeB_medias %>% map_df(as_tibble)
timeA_medias <- dplyr::select(timeA_medias, -Use)
timeB_medias <- dplyr::select(timeB_medias, -Use)
partida <- cbind(timeA_medias, timeB_medias)
colnames(partida) <- c('time1R', 'time1ACS', 'time1KAST', 'time1KD', 'time1ADR',
'time2R', 'time2ACS', 'time2KAST', 'time2KD', 'time2ADR')
partida <- select(partida, 'time1R', 'time2R', 'time1ACS', 'time2ACS', 'time1KAST', 'time2KAST', 'time1KD', 'time2KD',
'time1ADR', 'time2ADR')
partida <- as.data.frame(t(colMeans(partida)))
if(resultado == TRUE){
ganhador <- get_Ganhadores(url_partida)
partida <- cbind(partida, ganhador)
}
#else(){}
return(partida)
}
, error = function(e){cat('error:', conditionMessage(e), '\n')})
}
medias_Times('https://www.vlr.gg/167348/koi-vs-nrg-esports-champions-tour-2023-lock-in-s-o-paulo-alpha-ro16')
#' Médias dos times.
#' Função que calcula as médias de cada estatística para os dois times de uma determinada partida.
#' Para utilizar: medias_Times()
#' @export
# Função medias_times -------------------------------------------------------------------------------------
medias_Times <- function (url_partida, resultado = F){
tryCatch(
{
# Pegando os dados no link da partida -------------------------------------------------------------------
links_jogadores <- read_html(url_partida) %>%
html_nodes('td.mod-player a') %>%
html_attr('href')
# Separando os nomes dos jogadores de cada time em 2 arrays
timeA <- links_jogadores[1:5]
timeB <- links_jogadores[6:10]
# Criando os links usando os nomes dos jogadores para ficar entre '...vlr.gg' e '/?timespan...'
n <- 1
for (i in timeA){
timeA[n] <- paste('https://www.vlr.gg', '/?timespan=all', sep = i)
n = n + 1
}
n <- 1
for(i in timeB){
timeB[n] <- paste('https://www.vlr.gg', '/?timespan=all', sep = i)
n = n + 1
}
timeA_medias <- list()
timeB_medias <- list()
for (i in timeA){
timeA_medias[[length(timeA_medias)+1]] <- medias_Jogadores(i)
}
for (i in timeB){
timeB_medias[[length(timeB_medias)+1]] <- medias_Jogadores(i)
}
timeA_medias <- timeA_medias %>% map_df(as_tibble)
timeB_medias <- timeB_medias %>% map_df(as_tibble)
timeA_medias <- dplyr::select(timeA_medias, -Use)
timeB_medias <- dplyr::select(timeB_medias, -Use)
partida <- cbind(timeA_medias, timeB_medias)
colnames(partida) <- c('time1R', 'time1ACS', 'time1KAST', 'time1KD', 'time1ADR',
'time2R', 'time2ACS', 'time2KAST', 'time2KD', 'time2ADR')
partida <- select(partida, 'time1R', 'time2R', 'time1ACS', 'time2ACS', 'time1KAST', 'time2KAST', 'time1KD', 'time2KD',
'time1ADR', 'time2ADR')
partida <- as.data.frame(t(colMeans(partida)))
if(resultado == TRUE){
ganhador <- get_Ganhadores(url_partida)
partida <- cbind(partida, ganhador)
}
#else(){}
return(partida)
}
, error = function(e){cat('error:', conditionMessage(e), '\n')})
}
medias_Times('https://www.vlr.gg/167348/koi-vs-nrg-esports-champions-tour-2023-lock-in-s-o-paulo-alpha-ro16')
medias_Times('https://www.vlr.gg/167348/koi-vs-nrg-esports-champions-tour-2023-lock-in-s-o-paulo-alpha-ro16', resultado = T)
medias_Times('https://www.vlr.gg/165638/wlgaming-esports-vs-macko-esports-challengers-league-italy-rinascimento-split-1-w4', resultado = T)
length(jogos)
nrow(jogos)
jogos_scale <- read.csv2('csv/partidas_5.csv') %>% select(-X, -ganhador)
jogos_scale <- rbind(jogos_scale, partida)
partida <- jogos_scale[nrow(jogos_scale)+1,]
View(partida)
partida <- jogos_scale[nrow(jogos_scale),]
View(partida)
html_lido <- read_html(as.character('https://www.vlr.gg/165638/wlgaming-esports-vs-macko-esports-challengers-league-italy-rinascimento-split-1-w4'))
dados_jogador <- html_nodes(html_lido, 'table') %>%
html_table()
html_lido <- read_html(as.character('https://www.vlr.gg/player/570/m1tez'))
dados_jogador <- html_nodes(html_lido, 'table') %>%
html_table()
rm(medias_Times)
medias_Jogadores('https://www.vlr.gg/167348/koi-vs-nrg-esports-champions-tour-2023-lock-in-s-o-paulo-alpha-ro16')
rlang::last_error()
rlang::last_trace()
medias_Jogadores('https://www.vlr.gg/165638/wlgaming-esports-vs-macko-esports-challengers-league-italy-rinascimento-split-1-w4')
