algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
s <- 1
w <- 0.1
while ( i < 0.80) {
acharseed(s)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
# Carregando pacotes --------------------------------------------------------------------------------------
library(dplyr)
library(tidyr)
library(rvest)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
# Carregando partidas diarias e unindo emum df ------------------------------------------------------------
jogos_1 <- read.csv2('csv/2023-02-19_partidas.csv') %>% dplyr::select(-X)
jogos_2 <- read.csv2('csv/2023-02-20_partidas.csv') %>% dplyr::select(-X)
jogos_3 <- read.csv2('csv/2023-02-21_partidas.csv') %>% dplyr::select(-X)
jogos_4 <- read.csv2('csv/2023-02-22_partidas.csv') %>% dplyr::select(-X)
jogos_5 <- read.csv2('csv/2023-02-23_partidas.csv') %>% dplyr::select(-X)
# Carregando partidas diarias e unindo emum df ------------------------------------------------------------
jogos_1 <- read.csv2('csv/2023-02-19_partidas.csv') %>% dplyr::select(-X)
# Carregando partidas diarias e unindo emum df ------------------------------------------------------------
jogos_1 <- read.csv2('csv/catalogacao_diaria/2023-02-19_partidas.csv') %>% dplyr::select(-X)
jogos_2 <- read.csv2('csv/catalogacao_diaria/2023-02-20_partidas.csv') %>% dplyr::select(-X)
jogos_3 <- read.csv2('csv/catalogacao_diaria/2023-02-21_partidas.csv') %>% dplyr::select(-X)
jogos_4 <- read.csv2('csv/catalogacao_diaria/2023-02-22_partidas.csv') %>% dplyr::select(-X)
jogos_5 <- read.csv2('csv/catalogacao_diaria/2023-02-23_partidas.csv') %>% dplyr::select(-X)
jogos <- cbind(jogos_1, jogos_2, jogos_3, jogos_4, jogos_5)
jogos <- rbind(jogos_1, jogos_2, jogos_3, jogos_4, jogos_5)
jogos <- rbind(jogos_1, jogos_2, jogos_3, jogos_4)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
s <- 1
w <- 0.1
while ( i < 0.83) {
acharseed(s)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
while ( i < 0.85) {
acharseed(s)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
# Atualizando a seed para achar a melhor neuralnetwork -------------------------------------------------------
set.seed(209) #4 #59
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
acharnn <- function(){
n <<- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(9),
err.fct = "sse",
linear.output = F,
threshold = 0.8,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict <<- compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <<- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
z <<- ifelse(i>z, z <<- i, z <<- z)
print(z)
}
z <- 0.1
while (i < 0.9) {
acharnn()
}
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
nn2 <- as.factor(nn2)
x <- confusionMatrix(nn2, test_data$ganhador)
x <- as.data.frame(x$table)
# Plot
ggplot(data = x, mapping = aes(x = Reference, y = Prediction)) +
geom_tile(aes(fill = Freq), colour = 'white') +
geom_text(aes(label = sprintf('%1.0f', Freq)), vjust = 1) +
scale_fill_gradient(low = 'white', high = 'green') +
theme_bw() + theme(legend.position = 'none')
nn2 <- as.factor(nn2)
x <- confusionMatrix(nn2, test_data$ganhador)
x <- as.data.frame(x$table)
x
View(predictVstest)
while (i < 1) {
acharnn()
}
#Log Loss
logLoss(actual = test_data$ganhador, predicted = Predict$net.result)
View(test_data)
View(predictVstest)
Predict = compute(n, test_data)
#Log Loss
logLoss(actual = test_data$ganhador, predicted = Predict$net.result)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
nn2 <- as.factor(nn2)
x <- confusionMatrix(nn2, test_data$ganhador)
x <- as.data.frame(x$table)
#Log Loss
logLoss(actual = test_data$ganhador, predicted = Predict$net.result)
Predict$net.result
test_data$ganhador
#Log Loss
logLoss(actual = predictVstest$ganhador, predicted = predictVstest$Predict$net.result)
#Log Loss
logLoss(actual = predictVstest$ganhador, predicted = predictVstest$`Predict$net.result`)
while (i < 0.9) {
acharnn()
}
i < 0.1
i <- 0.1
while (i < 0.9) {
acharnn()
}
#Log Loss
logLoss(actual = test_data$ganhador, predicted = Predict$net.result)
# Plot
ggplot(data = x, mapping = aes(x = Reference, y = Prediction)) +
geom_tile(aes(fill = Freq), colour = 'white') +
geom_text(aes(label = sprintf('%1.0f', Freq)), vjust = 1) +
scale_fill_gradient(low = 'white', high = 'green') +
theme_bw() + theme(legend.position = 'none')
# Carregando partidas diarias e unindo emum df ------------------------------------------------------------
jogos_1 <- read.csv2('csv/catalogacao_diaria/2023-02-19_partidas.csv') %>% dplyr::select(-X)
jogos_2 <- read.csv2('csv/catalogacao_diaria/2023-02-20_partidas.csv') %>% dplyr::select(-X)
jogos_3 <- read.csv2('csv/catalogacao_diaria/2023-02-21_partidas.csv') %>% dplyr::select(-X)
jogos_4 <- read.csv2('csv/catalogacao_diaria/2023-02-22_partidas.csv') %>% dplyr::select(-X)
jogos <- rbind(jogos_1, jogos_2, jogos_3, jogos_4)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.6, 0.4))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.6, 0.4))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
s <- 1
w <- 0.1
while ( i < 0.85) {
acharseed(s)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
# Atualizando a seed para achar a melhor neuralnetwork -------------------------------------------------------
set.seed(209) #4 #59
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.6, 0.4))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
acharnn <- function(){
n <<- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(9),
err.fct = "sse",
linear.output = F,
threshold = 0.8,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict <<- compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <<- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
z <<- ifelse(i>z, z <<- i, z <<- z)
print(z)
}
z <- 0.1
while (i < 0.9) {
acharnn()
}
while (i < 0.99) {
acharnn()
}
#Log Loss
logLoss(actual = test_data$ganhador, predicted = Predict$net.result)
View(predictVstest)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5, 1, 0)
nn2 <- as.factor(nn2)
x <- confusionMatrix(nn2, test_data$ganhador)
x <- as.data.frame(x$table)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <<- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
# Carregando partidas diarias e unindo emum df ------------------------------------------------------------
jogos_1 <- read.csv2('csv/catalogacao_diaria/2023-02-19_partidas.csv') %>% dplyr::select(-X)
jogos_2 <- read.csv2('csv/catalogacao_diaria/2023-02-20_partidas.csv') %>% dplyr::select(-X)
jogos_3 <- read.csv2('csv/catalogacao_diaria/2023-02-21_partidas.csv') %>% dplyr::select(-X)
jogos_4 <- read.csv2('csv/catalogacao_diaria/2023-02-22_partidas.csv') %>% dplyr::select(-X)
jogos <- rbind(jogos_1, jogos_2, jogos_3, jogos_4)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.6, 0.4))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.6, 0.4))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
s <- 1
w <- 0.1
while ( i < 0.85) {
acharseed(s)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
View(predictVstest)
nn2
View(test_data)
# Carregando partidas diarias e unindo emum df ------------------------------------------------------------
jogos_1 <- read.csv2('csv/catalogacao_diaria/2023-02-19_partidas.csv') %>% dplyr::select(-X)
jogos_2 <- read.csv2('csv/catalogacao_diaria/2023-02-20_partidas.csv') %>% dplyr::select(-X)
jogos_3 <- read.csv2('csv/catalogacao_diaria/2023-02-21_partidas.csv') %>% dplyr::select(-X)
jogos_4 <- read.csv2('csv/catalogacao_diaria/2023-02-22_partidas.csv') %>% dplyr::select(-X)
jogos <- rbind(jogos_1, jogos_2, jogos_3, jogos_4)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.6, 0.4))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador == 1 ~ .,
data = training_data,
hidden = c(10, 10, 10),
err.fct = "sse",
linear.output = F,
threshold = 1,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
View(predictVstest)
nn2
# Carregando pacotes --------------------------------------------------------------------------------------
library(dplyr)
library(tidyr)
library(rvest)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
