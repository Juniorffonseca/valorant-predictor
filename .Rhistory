maxit = 1000,
trace = F,
algorithm = "rprop+")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <<- sum(predictions == test_data[, 31]) / nrow(test_data))
}
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
act.fct = 'logistic',
data = training_data,
size = 1,
linout = F,
threshold = 0.5,
maxit = 100,
trace = T,
algorithm = "backpropagation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
size = 1,
linout = F,
threshold = 0.5,
maxit = 100,
trace = T,
algorithm = "backpropagation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
MaxNWts = 100000,
size = 1,
linout = F,
threshold = 0.5,
maxit = 100,
trace = T,
algorithm = "backpropagation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
MaxNWts = 100000,
rang = 0.7,
size = 1,
linout = F,
threshold = 0.5,
maxit = 100,
trace = T,
algorithm = "backpropagation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
MaxNWts = 100000,
rang = 0.7,
skip = T,
size = 1,
linout = F,
threshold = 0.5,
maxit = 100,
trace = T,
algorithm = "backpropagation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <- sum(predictions == test_data[, 31]) / nrow(test_data))
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
MaxNWts = 100000,
rang = 0.7,
skip = T,
size = 5,
linout = F,
threshold = 0.5,
maxit = 100,
trace = T,
algorithm = "backpropagation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <- sum(predictions == test_data[, 31]) / nrow(test_data))
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
decay = 0.1,
MaxNWts = 100000,
rang = 0.7,
skip = T,
size = 5,
linout = F,
threshold = 0.5,
maxit = 100,
trace = T,
algorithm = "backpropagation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <- sum(predictions == test_data[, 31]) / nrow(test_data))
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
decay = 0.1,
MaxNWts = 100000,
rang = 0.7,
skip = T,
size = 5,
linout = F,
threshold = 0.5,
maxit = 100,
trace = T,
algorithm = "backpropagation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <- sum(predictions == test_data[, 31]) / nrow(test_data))
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
decay = 0.1,
size = 1,
linout = F,
threshold = 0.5,
maxit = 100,
trace = T,
algorithm = "backpropagation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <- sum(predictions == test_data[, 31]) / nrow(test_data))
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
decay = 0.1,
size = 1,
linout = F,
threshold = 0.1,
maxit = 100,
trace = T,
algorithm = "backpropagation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <- sum(predictions == test_data[, 31]) / nrow(test_data))
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
decay = 0.1,
size = 1,
linout = F,
threshold = 0.1,
maxit = 100,
trace = T,
algorithm = "rprop-")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <- sum(predictions == test_data[, 31]) / nrow(test_data))
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
decay = 0.1,
size = 1,
linout = F,
threshold = 0.1,
maxit = 100,
trace = T,
algorithm = "rprop+")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <- sum(predictions == test_data[, 31]) / nrow(test_data))
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
Hess = T,
act.fct = 'logistic',
data = training_data,
decay = 0.1,
size = 1,
linout = F,
threshold = 0.1,
maxit = 100,
trace = T,
algorithm = "backpropragation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <- sum(predictions == test_data[, 31]) / nrow(test_data))
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
data = training_data,
decay = 0.1,
size = 1,
linout = F,
threshold = 0.1,
maxit = 100,
trace = T,
algorithm = "backpropragation")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <- sum(predictions == test_data[, 31]) / nrow(test_data))
achar_Seed <- function(seed){
set.seed(seed)
data_split <- initial_split(jogos, prop = 0.7, strata = "ganhador")
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(30)
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
data = training_data,
decay = 0.1,
size = 1,
linout = F,
threshold = 0.2,
maxit = 1000,
trace = F,
algorithm = "rprop+")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <<- sum(predictions == test_data[, 31]) / nrow(test_data))
}
s <- 1
while (accuracy < 0.85){
achar_Seed(s)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
while (accuracy < 0.83){
achar_Seed(s)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
s <- 1
while (accuracy < 0.83){
achar_Seed(s)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
rm (i)
while (accuracy < 0.83){
achar_Seed(s)
s <- s + 1
w <<- ifelse(accuracy>w, w <<- accuracy, w <<- w)
print(w)
}
w <- 0
while (accuracy < 0.83){
achar_Seed(s)
s <- s + 1
w <<- ifelse(accuracy>w, w <<- accuracy, w <<- w)
print(w)
}
achar_Nn <- function(){
n <- nnet(formula = ganhador == 1 ~ .,
data = training_data,
decay = 0.05,
size = 1,
linout = F,
threshold = 0.2,
maxit = 1000,
trace = F,
algorithm = "rprop+")
predictions <- predict(n, test_data[, -31])
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <<- sum(predictions == test_data[, 31]) / nrow(test_data))
z <<- ifelse(accuracy>z, z <<- i, z <<- z)
print(z)
}
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
data = training_data,
decay = 0.1,
size = 1,
linout = F,
threshold = 1,
maxit = 1000,
trace = F,
algorithm = "rprop+")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <<- sum(predictions == test_data[, 31]) / nrow(test_data))
achar_Seed <- function(seed){
set.seed(seed)
data_split <- initial_split(jogos, prop = 0.7, strata = "ganhador")
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(30)
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- nnet(formula = ganhador == 1 ~ .,
data = training_data,
decay = 0.1,
size = 1,
linout = F,
threshold = 1,
maxit = 1000,
trace = F,
algorithm = "rprop+")
# Fazer previsões usando o modelo treinado
predictions <- predict(n, test_data[, -31])
predictions <- ifelse(predictions > 0.5, 1, 0)
print(accuracy <<- sum(predictions == test_data[, 31]) / nrow(test_data))
}
s <- 1
while (accuracy < 0.83){
achar_Seed(s)
s <- s + 1
w <<- ifelse(accuracy>w, w <<- accuracy, w <<- w)
print(w)
}
while (accuracy < 0.83){
achar_Seed(s)
s <- s + 1
w <<- ifelse(accuracy>w, w <<- accuracy, w <<- w)
print(w)
}
library(caret)
model <- train(ganhador == 1 ~ ., data = training_data, method = "neuralnet")
model <- train(ganhador~ ., data = training_data, method = "neuralnet")
?train
model <- train(ganhador == 1 ~ ., training_data, na.action = na.fail, contrasts = NULL)
model <- train(ganhador ~ ., training_data, na.action = na.fail, contrasts = NULL)
predictions <- predict(model, newdata = testing)
predictions <- predict(model, newdata = test_data)
confusionMatrix(predictions, testing$target)
predictions <- predict(model, newdata = test_data)
confusionMatrix(predictions, test_data$ganhador)
predictions
length(predictions)
model <- train(ganhador == 1 ~ ., training_data, na.action = na.fail, contrasts = NULL)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
data_split <- initial_split(jogos, prop = 0.7, strata = "ganhador")
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(30)
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
View(training_data)
model <- train(ganhador == 1 ~ ., training_data, na.action = na.fail, contrasts = NULL)
model <- train(ganhador ~ ., training_data, na.action = na.fail, contrasts = NULL)
View(model)
model <- train(ganhador ~ ., training_data, contrasts = NULL)
View(model)
model <- train(ganhador == 1 ~ ., training_data, contrasts = NULL)
training_data$ganhador <- as.numeric(training_data$ganhador)
model <- train(ganhador == 1 ~ ., training_data, contrasts = NULL)
training_data$ganhador <- factor(training_data$ganhador, levels = c(0, 1), labels = c("perdedor", "vencedor"))
model <- train(ganhador == 1 ~ ., training_data, contrasts = NULL)
View(training_data)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
data_split <- initial_split(jogos, prop = 0.7, strata = "ganhador")
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(30)
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- factor(training_data$ganhador, levels = c(2, 1), labels = c("perdedor", "vencedor"))
View(training_data)
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github("Juniorffonseca/r-pacote-valorant")
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date("2023-02-19"), Sys.Date() - 1, by = "day")
nomes_arquivos <- paste0("csv/catalogacao_diaria/", format(datas, "%Y-%m-%d"), "_partidas.csv")
jogos_lista <- list()
for (arquivo in nomes_arquivos) {
jogos_lista[[arquivo]] <- read.csv2(arquivo) %>% select(-X)
}
jogos <- bind_rows(jogos_lista)
jogos$ganhador <- as.factor(jogos$ganhador)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
data_split <- initial_split(jogos, prop = 0.7, strata = "ganhador")
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(30)
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
model <- train(ganhador == 1 ~ ., training_data, contrasts = NULL)
model <- train(ganhador == 1 ~ ., training_data, contrasts = NULL, method = 'neuralnet')
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'neuralnet')
training_data$ganhador <- factor(training_data$ganhador)
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'neuralnet')
training_data$ganhador <- as.factor(training_data$ganhador)
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'neuralnet')
training_data <- training_data[complete.cases(training_data),]
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'neuralnet')
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'neuralnet', metric = accuracy)
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'neuralnet', metric = 'accuracy')
update.packages('caret')
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'neuralnet', metric = 'accuracy')
library(neuralnet)
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'neuralnet', metric = 'accuracy')
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'repeatedcv', metric = 'accuracy')
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'cv', metric = 'accuracy')
model <- train(ganhador ~ ., training_data, contrasts = NULL, method = 'nnet', metric = 'accuracy')
View(model)
model[["results"]][["Accuracy"]]
model <- train(ganhador == 1 ~ ., training_data, contrasts = NULL, method = 'nnet', metric = 'Accuracy')
model <- train(ganhador ~ ., training_data, method = 'nnet', metric = 'Accuracy')
View(model)
summary(model)
