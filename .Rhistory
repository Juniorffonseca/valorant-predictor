plot_ly(data = predictVstest, x = ~previsao, y = ~ganhador,
color = ~factor(ganhador), colors = c("red", "green"), type = "scatter",
mode = "markers", marker = list(size = 6)) %>%
layout(xaxis = list(title = "Porcentagem"), yaxis = list(title = "Ganhador"),
legend = list(title = "Ganhador", font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = "line", x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = "gray", width = 2))))
plot_ly(data = predictVstest, x = ~previsao, y = ~ganhador,
color = ~factor(ganhador), colors = c("red", "green"), type = "scatter",
mode = "markers", marker = list(size = 5)) %>%
layout(xaxis = list(title = "Porcentagem"), yaxis = list(title = "Ganhador"),
legend = list(title = "Ganhador", font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = "line", x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = "gray", width = 2))))
plot_ly(data = predictVstest, x = ~previsao, y = ~ganhador,
color = ~factor(ganhador), colors = c("red", "green"), type = "scatter",
mode = "markers", marker = list(size = 6)) %>%
layout(xaxis = list(title = "Porcentagem"), yaxis = list(title = "Ganhador"),
legend = list(title = "Ganhador", font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = "line", x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = "gray", width = 2))))
plot_ly(data = predictVstest, x = ~previsao, y = ~ganhador,
color = ~factor(ganhador), colors = c("red", "green"), type = "scatter",
mode = "markers", marker = list(size = 3)) %>%
layout(xaxis = list(title = "Porcentagem"), yaxis = list(title = "Ganhador"),
legend = list(title = "Ganhador", font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = "line", x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = "gray", width = 2))))
plot_ly(data = predictVstest, x = ~previsao, y = ~ganhador,
color = ~factor(ganhador), colors = c("red", "green"), type = "scatter",
mode = "markers", marker = list(size = 4)) %>%
layout(xaxis = list(title = "Porcentagem"), yaxis = list(title = "Ganhador"),
legend = list(title = "Ganhador", font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = "line", x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = "gray", width = 2))))
taskscheduleR:::taskschedulerAddin()
# Carregando pacotes --------------------------------------------------------------------------------------
library(rvest)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(reshape2)
library(tidyverse)
library(neuralnet)
library(readr)
library(purrr)
library(valorant)
library(lubridate)
setwd('C:/Users/anonb/Documents/TCC_Pós/Scripts')
funcaoPagina <- function(pagina){
matchs <- read_html(pagina) %>%
html_nodes('a') %>% html_attr('href')
matchs <- matchs[15:64]
n <- 1
for (i in matchs){
matchs[n] <- paste('https://www.vlr.gg', matchs[n], sep = '')
n = n + 1
}
return(matchs)
}
a <- funcaoPagina('https://www.vlr.gg/matches')
n <- 1
b <- '' %>% .[0]
for (i in a){
tryCatch({
dia <- read_html(i) %>%
html_nodes('div.moment-tz-convert') %>% html_text(trim = T) %>% .[1] %>%
parse_date_time(., orders = "%A, %B %d", locale = "en_US")
tbd <- read_html(i) %>% html_nodes('table') %>% html_table() %>%
.[1:2] %>% map_df(as_tibble, .name_repair = 'minimal')
if(dia == Sys.Date() && !grepl('TBD', tbd[,1])){
b[length(b)+1] <- i
}
else{}
}
, error = function(e){cat('error:', conditionMessage(e), '\n')})
}
nome_arquivo_urls <- paste(Sys.Date(), '_urls.csv', sep = '')
write.csv2(b, paste('csv/catalogacao_diaria/', nome_arquivo_urls, sep = ''))
m <- 1
dff <- list()
for (i in b){
tryCatch({
dff[[length(dff)+1]] <- medias_Times(b[m])
m = m + 1
}
, error = function(e){cat('error:', conditionMessage(e), '\n')})
}
dff <- dff %>% map_df(as_tibble)
nome_arquivo_partidas <- paste(Sys.Date(), '_partidas.csv', sep = '')
write.csv2(dff, paste('csv/catalogacao_diaria/', nome_arquivo_partidas, sep = ''))
View(dff)
View(tbd)
View(tbd)
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github("Juniorffonseca/r-pacote-valorant")
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date("2023-02-19"), Sys.Date() - 1, by = "day")
nomes_arquivos <- paste0("csv/catalogacao_diaria/", format(datas, "%Y-%m-%d"), "_partidas.csv")
jogos_lista <- list()
for (arquivo in nomes_arquivos) {
jogos_lista[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
jogos <- bind_rows(jogos_lista) %>% select(-X)
jogos$ganhador <- as.factor(jogos$ganhador)
table(jogos$ganhador)
modelo_jogos <- glm(formula = ganhador ~ .,
data = jogos,
family = "binomial")
summary(modelo_jogos)
extract_eq(modelo_jogos, use_coefs = T,
wrap = T, show_distribution = T) %>%
kable() %>%
kable_styling(bootstrap_options = "striped",
full_width = F,
font_size = 25)
confint(modelo_jogos, level = 0.95)
logLik(modelo_jogos)
predict(object = modelo_jogos,
data.frame(dist = 7),
type = "response")
?predict
jogos$phat <- modelo_jogos$fitted.values
View(jogos)
ggplotly(
jogos %>%
ggplot() +
geom_point(aes(x = sem, y = ganhador), color = "orange", size = 2) +
geom_smooth(aes(x = sem, y = phat),
method = "lm", formula = y ~ x,
se = FALSE,
color = "darkorchid", size = 2) +
labs(x = "Quantidade de Semáforos",
y = "jogos") +
theme_bw()
)
confusionMatrix(table(predict(modelo_jogos, type = "response") >= 0.5,
Atrasado$atrasado == 1)[2:1, 2:1])
confusionMatrix(table(predict(modelo_jogos, type = "response") >= 0.5,
jogos$ganhador == 1)[2:1, 2:1])
confusionMatrix(table(predict(modelo_jogos, type = "response") >= 0.5,
jogos$ganhador == 1)[2:1, 2:1])
predict(modelo_jogos, type = "response")
confusionMatrix(table(predict(modelo_jogos, type = "response") >= 0.5,
jogos$ganhador == 1)[2:1, 2:1])
?confusionMatrix
caret::confusionMatrix(table(predict(modelo_jogos, type = "response") >= 0.5,
jogos$ganhador == 1)[2:1, 2:1])
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github("Juniorffonseca/r-pacote-valorant")
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date("2023-02-19"), Sys.Date() - 1, by = "day")
nomes_arquivos <- paste0("csv/catalogacao_diaria/", format(datas, "%Y-%m-%d"), "_partidas.csv")
jogos_lista <- list()
for (arquivo in nomes_arquivos) {
jogos_lista[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
jogos <- bind_rows(jogos_lista) %>% select(-X)
jogos$ganhador <- as.factor(jogos$ganhador)
#write.csv2(jogos, 'csv/partidas_teste.csv')
#jogos <- read.csv2('csv/partidas_teste.csv')
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
data_split <- initial_split(jogos, prop = 0.7, strata = "ganhador")
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(30)
t <- 1 #thresholder
formula <- 'ganhador == 1 ~ .'
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(formula,
data = training_data,
hidden = hidden_n,
err.fct = "sse",
linear.output = F,
threshold = t,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
#plot(n, rep = 1)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
# Achar uma boa seed -------------------------------------------------------------------------------------
s <- 1 # 10679 13/03 0.7959% acuracia 98 partidas
w <- 0.1
while ( i < 0.79) {
achar_Seed(s, hidden_n, t = 0.9)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github("Juniorffonseca/r-pacote-valorant")
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(valorant)
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github("Juniorffonseca/r-pacote-valorant")
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date("2023-02-19"), Sys.Date() - 1, by = "day")
nomes_arquivos <- paste0("csv/catalogacao_diaria/", format(datas, "%Y-%m-%d"), "_partidas.csv")
jogos_lista <- list()
for (arquivo in nomes_arquivos) {
jogos_lista[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
jogos <- bind_rows(jogos_lista) %>% select(-X)
jogos$ganhador <- as.factor(jogos$ganhador)
ggplotly(
jogos %>%
ggplot() +
geom_point(aes(x = R, y = ganhador), color = "orange", size = 2) +
geom_smooth(aes(x = R, y = ganhador),
method = "glm", formula = y ~ x,
method.args = list(family = "binomial"),
se = FALSE,
color = "darkorchid", size = 2) +
labs(x = "Quantidade de Semáforos",
y = "Atrasado") +
theme_bw()
)
View(jogos)
ggplotly(
jogos %>%
ggplot() +
geom_point(aes(x = time1R, y = ganhador), color = "orange", size = 2) +
geom_smooth(aes(x = time1R, y = ganhador),
method = "glm", formula = y ~ x,
method.args = list(family = "binomial"),
se = FALSE,
color = "darkorchid", size = 2) +
labs(x = "Quantidade de Semáforos",
y = "Atrasado") +
theme_bw()
)
ggplotly(
jogos %>%
ggplot() +
geom_point(aes(x = time1R, y = ganhador), color = "orange", size = 2) +
geom_smooth(aes(x = time1R, y = ganhador),
method = "glm", formula = y ~ x,
method.args = list(family = "binomial"),
se = FALSE,
color = "darkorchid", size = 2) +
labs(x = "Estatística",
y = "Ganhador") +
theme_bw()
)
ggplotly(
jogos %>%
ggplot() +
geom_point(aes(x = time2R, y = ganhador), color = "orange", size = 2) +
geom_smooth(aes(x = time2R, y = ganhador),
method = "glm", formula = y ~ x,
method.args = list(family = "binomial"),
se = FALSE,
color = "darkorchid", size = 2) +
labs(x = "Estatística",
y = "Ganhador") +
theme_bw()
)
ggplotly(
jogos %>%
ggplot() +
geom_point(aes(x = time2R, y = ganhador), color = "orange", size = 2) +
geom_point(aes(x = time1R, y = ganhador), color = 'blue', size = 2) +
labs(x = "Estatística",
y = "Ganhador") +
theme_bw()
)
ggplotly(
jogos %>%
ggplot() +
geom_point(aes(x = time2R, y = ganhador), color = "orange", size = 2) +
geom_point(aes(x = time1R, y = ganhador), color = 'blue', size = 1) +
labs(x = "Estatística",
y = "Ganhador") +
theme_bw()
)
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github("Juniorffonseca/r-pacote-valorant")
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date("2023-02-19"), Sys.Date() - 1, by = "day")
nomes_arquivos <- paste0("csv/catalogacao_diaria/", format(datas, "%Y-%m-%d"), "_partidas.csv")
jogos_lista <- list()
for (arquivo in nomes_arquivos) {
jogos_lista[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
jogos <- bind_rows(jogos_lista) %>% select(-X)
jogos$ganhador <- as.factor(jogos$ganhador)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
data_split <- initial_split(jogos, prop = 0.7, strata = "ganhador")
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(30)
t <- 1 #thresholder
formula <- 'ganhador == 1 ~ .'
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(formula,
data = training_data,
hidden = hidden_n,
err.fct = "sse",
linear.output = F,
threshold = t,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
# Achar uma boa seed -------------------------------------------------------------------------------------
s <- 1 # 10679 13/03 0.7959% acuracia 98 partidas
w <- 0.1
while ( i < 0.79) {
achar_Seed(s, hidden_n, t = 0.9)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
while ( i < 0.77) {
achar_Seed(s, hidden_n, t = 0.9)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
# Atualizando a seed para achar a melhor neuralnetwork ----------------------------------------------------
set.seed(s-1)
data_split <- initial_split(jogos, prop = 0.7, strata = "ganhador")
training_data <- training(data_split)
test_data <- testing(data_split)
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
Predict = compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
# Procurando uma rede neural com acuracia a cima de determinado percentual --------------------------------
z <- 0.1
while (i < 0.82) {
achar_Nn(t = 0.9)
}
while (i < 0.80) {
achar_Nn(t = 0.9)
}
beep(8)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5, 1, 0)
nn2 <- as.factor(nn2)
x <- caret::confusionMatrix(nn2, test_data$ganhador)
F1 <- x$byClass['F1']
x <- as.data.frame(x$table)
predictVstest <- cbind(test_data, Predict$net.result)
names(predictVstest)[32] <- 'previsao'
# Plot
ggplot(data = x, mapping = aes(x = Reference, y = Prediction)) +
geom_tile(aes(fill = Freq), colour = 'white') +
geom_text(aes(label = sprintf('%1.0f', Freq)), vjust = 1) +
scale_fill_gradient(low = 'white', high = 'green') +
theme_bw() + theme(legend.position = 'none')
#Log Loss
logLoss(actual = test_data$ganhador, predicted = Predict$net.result)
#Plot distribuição
histogram(predictVstest$`Predict$net.result`, breaks = 98,
col = ifelse(as.factor(predictVstest$ganhador) == 1, "blue", "red"))
plot_ly(data = predictVstest, x = ~previsao, y = ~ganhador,
color = ~factor(ganhador), colors = c("red", "green"), type = "scatter",
mode = "markers", marker = list(size = 4)) %>%
layout(xaxis = list(title = "Porcentagem"), yaxis = list(title = "Ganhador"),
legend = list(title = "Ganhador", font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = "line", x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = "gray", width = 2))))
View(predictVstest)
save(n, file='26_03_nnet.rda') #26/03/2023 105/129 base de teste (0.8139535 acuracia)
