lineup <- html_nodes(html_lido, 'div.players') %>% html_text
if(length(lineup) != 0) {c[length(c)+1] <- i}
}
c <- '' %>% .[0]
for (i in b){
html_lido <- read_html(as.character(i))
lineup <- html_nodes(html_lido, 'div.players') %>% html_text
if(length(lineup) != 0) {c[length(c)+1] <- i}
}
# Criar um vetor para armazenar os resultados
resultados <- vector("list", length(c))
resultados
# Carregando pacotes --------------------------------------------------------------------------------------
library(rvest)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(reshape2)
library(tidyverse)
library(neuralnet)
library(readr)
library(purrr)
library(lubridate)
setwd('C:/Users/anonb/Documents/CSGO_predictor') #colocar o endereço da pasta onde está o script
matchs <- read_html(paste('https://tips.gg/csgo/matches/', format(Sys.Date(), '%d-%m-%Y'), sep = '')) %>%
html_nodes('a') %>% html_attr('href')
matchs <- matchs[66:length(matchs)]
# Encontra os índices dos links que começam com "https://tips.gg/match/"
indices <- grep("^https://tips\\.gg/match/", matchs)
# Seleciona apenas os links correspondentes
a <- matchs[indices]
b <- '' %>% .[0]
for (url in a) {
# Extrai a data da URL
data_str <- str_extract(url, "\\d{2}-\\d{2}-\\d{4}")
# Extrai o dia, mês e ano da data
dia <- str_sub(data_str, start = 1, end = 2)
mes <- str_sub(data_str, start = 4, end = 5)
ano <- str_sub(data_str, start = 7, end = 10)
# Concatena o dia, mês e ano em uma string no formato "aaaa-mm-dd"
data <- paste(ano, mes, dia, sep = "-")
# Converte a data para o formato "aaaa-mm-dd"
data <- as.Date(data)
# Compara a data com o dia atual e imprime uma mensagem apropriada
if (data == Sys.Date()) {
b[length(b)+1] <- url
}
}
c <- '' %>% .[0]
for (i in b){
html_lido <- read_html(as.character(i))
lineup <- html_nodes(html_lido, 'div.players') %>% html_text
if(length(lineup) != 0) {c[length(c)+1] <- i}
}
# Criar um vetor para armazenar os resultados
resultados <- vector("list", length(c))
# Iterar sobre os elementos do vetor c
for (i in seq_along(c)) {
tryCatch({
# Obter o resultado para o elemento i
resultado <- medias_times_f(c[i])
# Armazenar o resultado no vetor de resultados
resultados[[i]] <- resultado
}, error = function(e) {
# Se ocorrer um erro, imprimir uma mensagem de aviso e continuar o loop
cat(paste("Não foi possível obter o resultado para o time", c[i], ": ", e$message, "\n"))
})
}
medias_jogadores_f <- function (url_jogador)
{
html_lido <- read_html(as.character(url_jogador))
dados_jogador <- html_nodes(html_lido, 'table') %>% html_table()
dados_jogador_1 <- cbind(dados_jogador[[1]]$X2, dados_jogador[[1]]$X4)
dados_jogador_2 <- dados_jogador[[2]]$X4
dados_jogador_2[length(dados_jogador_2)] <- dados_jogador[[2]]$X2[length(dados_jogador[[2]]$X2)]
dados_jogador <- c(dados_jogador_1[,1], dados_jogador_1[,2], dados_jogador_2)
return(dados_jogador)
}
medias_times_f <- function (url_partida, resultado = F)
{
tryCatch({
links_jogadores <- read_html(as.character(url_partida)) %>% html_nodes("div.player a") %>%
html_attr("href")
timeA <- links_jogadores[1:5]
timeB <- links_jogadores[6:10]
timeA_medias <- list()
timeB_medias <- list()
for (i in timeA) {
timeA_medias[[length(timeA_medias) + 1]] <- medias_jogadores_f(i)
}
for (i in timeB) {
timeB_medias[[length(timeB_medias) + 1]] <- medias_jogadores_f(i)
}
timeA_medias <- as.data.frame(timeA_medias) %>% t() %>% as.data.frame()
timeB_medias <- as.data.frame(timeB_medias) %>% t() %>% as.data.frame()
partida <- cbind(timeA_medias, timeB_medias)
colnames(partida) <- make.unique(colnames(partida))
partida <- partida %>%
mutate_if(is.character, parse_number)
partida <- as.data.frame(t(colMeans(partida)))
# if (resultado == TRUE) {
#   ganhador <- get_Ganhadores(url_partida)
#   partida <- cbind(partida, ganhador)
# }
return(partida)
}, error = function(e) {
cat("error:", conditionMessage(e), "\n")
})
}
# Carregando pacotes --------------------------------------------------------------------------------------
library(rvest)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(reshape2)
library(tidyverse)
library(neuralnet)
library(readr)
library(purrr)
library(lubridate)
setwd('C:/Users/anonb/Documents/CSGO_predictor') #colocar o endereço da pasta onde está o script
matchs <- read_html(paste('https://tips.gg/csgo/matches/', format(Sys.Date(), '%d-%m-%Y'), sep = '')) %>%
html_nodes('a') %>% html_attr('href')
matchs <- matchs[66:length(matchs)]
# Encontra os índices dos links que começam com "https://tips.gg/match/"
indices <- grep("^https://tips\\.gg/match/", matchs)
# Seleciona apenas os links correspondentes
a <- matchs[indices]
b <- '' %>% .[0]
for (url in a) {
# Extrai a data da URL
data_str <- str_extract(url, "\\d{2}-\\d{2}-\\d{4}")
# Extrai o dia, mês e ano da data
dia <- str_sub(data_str, start = 1, end = 2)
mes <- str_sub(data_str, start = 4, end = 5)
ano <- str_sub(data_str, start = 7, end = 10)
# Concatena o dia, mês e ano em uma string no formato "aaaa-mm-dd"
data <- paste(ano, mes, dia, sep = "-")
# Converte a data para o formato "aaaa-mm-dd"
data <- as.Date(data)
# Compara a data com o dia atual e imprime uma mensagem apropriada
if (data == Sys.Date()) {
b[length(b)+1] <- url
}
}
medias_jogadores_f <- function (url_jogador)
{
html_lido <- read_html(as.character(url_jogador))
dados_jogador <- html_nodes(html_lido, 'table') %>% html_table()
dados_jogador_1 <- cbind(dados_jogador[[1]]$X2, dados_jogador[[1]]$X4)
dados_jogador_2 <- dados_jogador[[2]]$X4
dados_jogador_2[length(dados_jogador_2)] <- dados_jogador[[2]]$X2[length(dados_jogador[[2]]$X2)]
dados_jogador <- c(dados_jogador_1[,1], dados_jogador_1[,2], dados_jogador_2)
return(dados_jogador)
}
medias_times_f <- function (url_partida, resultado = F)
{
tryCatch({
links_jogadores <- read_html(as.character(url_partida)) %>% html_nodes("div.player a") %>%
html_attr("href")
timeA <- links_jogadores[1:5]
timeB <- links_jogadores[6:10]
timeA_medias <- list()
timeB_medias <- list()
for (i in timeA) {
timeA_medias[[length(timeA_medias) + 1]] <- medias_jogadores_f(i)
}
for (i in timeB) {
timeB_medias[[length(timeB_medias) + 1]] <- medias_jogadores_f(i)
}
timeA_medias <- as.data.frame(timeA_medias) %>% t() %>% as.data.frame()
timeB_medias <- as.data.frame(timeB_medias) %>% t() %>% as.data.frame()
partida <- cbind(timeA_medias, timeB_medias)
colnames(partida) <- make.unique(colnames(partida))
partida <- partida %>%
mutate_if(is.character, parse_number)
partida <- as.data.frame(t(colMeans(partida)))
# if (resultado == TRUE) {
#   ganhador <- get_Ganhadores(url_partida)
#   partida <- cbind(partida, ganhador)
# }
return(partida)
}, error = function(e) {
cat("error:", conditionMessage(e), "\n")
})
}
c <- '' %>% .[0]
for (i in b){
html_lido <- read_html(as.character(i))
lineup <- html_nodes(html_lido, 'div.players') %>% html_text
if(length(lineup) != 0) {c[length(c)+1] <- i}
}
# Criar um vetor para armazenar os resultados
resultados <- vector("list", length(c))
# Iterar sobre os elementos do vetor c
for (i in seq_along(c)) {
tryCatch({
# Obter o resultado para o elemento i
resultado <- medias_times_f(c[i])
# Armazenar o resultado no vetor de resultados
resultados[[i]] <- resultado
}, error = function(e) {
# Se ocorrer um erro, imprimir uma mensagem de aviso e continuar o loop
cat(paste("Não foi possível obter o resultado para o time", c[i], ": ", e$message, "\n"))
})
}
# Visualizar os resultados
resultados
is.not.null <- function(x) !is.null(x)
c <- c[which(sapply(resultados, is.not.null))]
nome_arquivo_urls <- paste(Sys.Date(), '_urls.csv', sep = '')
write.csv2(c, paste('dados/catalogacao_diaria/', nome_arquivo_urls, sep = ''))
nome_arquivo_urls <- paste(Sys.Date(), '_urls.csv', sep = '')
write.csv2(c, paste('dados/catalogacao_diaria/', nome_arquivo_urls, sep = ''))
m <- 1
dff <- list()
for (i in c){
tryCatch({
dff[[length(dff)+1]] <- medias_times_f(c[m])
m = m + 1
}
, error = function(e){cat('error:', conditionMessage(e), '\n')})
}
dff <- dff %>% map_df(as_tibble)
nome_arquivo_partidas <- paste(Sys.Date(), '_partidas.csv', sep = '')
write.csv2(dff, paste('dados/catalogacao_diaria/', nome_arquivo_partidas, sep = ''))
taskscheduleR:::taskschedulerAddin()
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(ROCR)
library(kableExtra)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date('2023-03-14'), Sys.Date() - 1, by = 'day')
nomes_arquivos <- paste0('csv/previsao_diaria/', format(datas, '%Y-%m-%d'), '_acuracia.csv')
acuracia <- list()
for (arquivo in nomes_arquivos) {
acuracia[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
acuracia <- bind_rows(acuracia) %>% select(-X)
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(ROCR)
library(kableExtra)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date('2023-03-14'), Sys.Date() - 1, by = 'day')
nomes_arquivos <- paste0('csv/previsao_diaria/', format(datas, '%Y-%m-%d'), '_acuracia.csv')
acuracia <- list()
for (arquivo in nomes_arquivos) {
acuracia[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
warnings()
setwd('C:/Users/anonb/Documents/TCC_Pós/Scripts')
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date('2023-03-14'), Sys.Date() - 1, by = 'day')
nomes_arquivos <- paste0('csv/previsao_diaria/', format(datas, '%Y-%m-%d'), '_acuracia.csv')
acuracia <- list()
for (arquivo in nomes_arquivos) {
acuracia[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
acuracia <- bind_rows(acuracia) %>% select(-X)
acertos <- sum(acuracia$acertos)
erros <- sum(acuracia$erros)
print(acuracia_total <- acertos/(acertos+erros))
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
remotes::install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(ROCR)
library(kableExtra)
library(glmnet)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date('2023-02-19'), Sys.Date() - 1, by = 'day')
nomes_arquivos <- paste0('csv/catalogacao_diaria/', format(datas, '%Y-%m-%d'), '_partidas.csv')
jogos_lista <- list()
for (arquivo in nomes_arquivos) {
jogos_lista[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
jogos <- bind_rows(jogos_lista) %>% select(-X)
# Selecione as variáveis que serão usadas para ajustar o modelo
vars <- c('RND', 'R', 'ACS', 'KAST', 'KD', 'ADR', 'KPR', 'APR', 'FKPR', 'FDPR', 'K', 'D', 'A', 'FK', 'FD')
# Crie novas variáveis que calculam a diferença entre todas as estatísticas dos dois times
for (i in vars) {
new_var <- paste0(i, "_diff")
jogos[[new_var]] <- jogos[[paste0("time1", i)]] - jogos[[paste0("time2", i)]]
}
# Remova as colunas das variáveis originais
jogos <- select(jogos, ends_with("_diff"), ganhador)
jogos$ganhador <- as.factor(jogos$ganhador)
#write.csv2(jogos, 'csv/partidas_teste.csv')
#jogos <- read.csv2('csv/partidas_teste.csv')
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
data_split <- initial_split(jogos, prop = 0.7, strata = 'ganhador')
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(15)
#hidden_n <- c(30)
# formula <- 'ganhador == 1 ~ time1FKPR + time1FDPR + time1KPR + time1APR + time1KD + time1R + time1ADR +
# time2FKPR + time2FDPR + time2KPR + time2APR + time2KD + time2R + time2ADR'
formula <- 'ganhador == 1 ~ .'
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(formula,
data = training_data,
hidden = hidden_n,
err.fct = 'sse',
linear.output = F,
threshold = 0.5,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
#plot(n, rep = 1)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
# Achar uma boa seed -------------------------------------------------------------------------------------
s <- 1 # 10679 13/03 0.7959% acuracia 98 partidas
# 68529 08/04
w <- 0.1
while ( i < 0.77) {
achar_Seed(s, hidden_n, t = 0.5, mostrar_i = F)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
# Atualizando a seed para achar a melhor neuralnetwork ----------------------------------------------------
set.seed(s-1) #22263
data_split <- initial_split(jogos, prop = 0.7, strata = 'ganhador')
training_data <- training(data_split)
test_data <- testing(data_split)
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
Predict = compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
# Procurando uma rede neural com acuracia acima de determinado percentual --------------------------------
z <- 0.1
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(formula,
data = training_data,
hidden = hidden_n,
err.fct = 'sse',
linear.output = F,
threshold = 0.5,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5, 1, 0)
nn2 <- as.factor(nn2)
x <- caret::confusionMatrix(nn2, test_data$ganhador)
F1 <- x$byClass['F1']
x <- as.data.frame(x$table)
predictVstest <- cbind(test_data, Predict$net.result)
names(predictVstest)[length(predictVstest)] <- 'previsao'
# Curva ROC
ROC <- roc(response = as.factor(predictVstest$ganhador),
predictor = predictVstest$previsao)
predicoes <- ROCR::prediction(predictions = predictVstest$previsao,
labels = as.factor(predictVstest$ganhador))
dados_curva_roc <- performance(predicoes, measure = "sens")
sensitividade <- (performance(predicoes, measure = "sens"))@y.values[[1]]
especificidade <- (performance(predicoes, measure = "spec"))@y.values[[1]]
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = 'grey40', size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = '1 - Especificidade',
y = 'Sensitividade',
title = paste('Área abaixo da curva:',
round(ROC$auc, 4),
'|',
'Coeficiente de Gini:',
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = 'black', fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
# Plot matriz de confusão
ggplot(data = x, mapping = aes(x = Reference, y = Prediction)) +
geom_tile(aes(fill = Freq), colour = 'white') +
geom_text(aes(label = sprintf('%1.0f', Freq)), vjust = 1) +
scale_fill_gradient(low = 'white', high = 'green') +
theme_bw() + theme(legend.position = 'none')
#Log Loss
logLoss(actual = test_data$ganhador, predicted = Predict$net.result)
#Plot distribuição
plot_ly(data = predictVstest, x = ~previsao, y = ~ganhador,
color = ~factor(ganhador), colors = c('red', 'green'), type = 'scatter',
mode = 'markers', marker = list(size = 4)) %>%
layout(xaxis = list(title = 'Porcentagem'), yaxis = list(title = 'Ganhador'),
legend = list(title = 'Ganhador', font = list(size = 16)),
margin = list(l = 50, r = 50, t = 50, b = 50),
shapes = list(list(type = 'line', x0 = 0.5, x1 = 0.5, y0 = 0, y1 = 1,
line = list(color = 'gray', width = 2))))
# Fazer previsões nos dados de treinamento e teste usando a rede neural treinada
train_preds <- predict(n, training_data)
test_preds <- predict(n, test_data)
train_preds <- ifelse(train_preds > 0.5, 1, 0)
test_preds <- ifelse(test_preds > 0.5, 1, 0)
# Calcular a precisão da rede neural nos conjuntos de treinamento e teste
train_acc <- mean(train_preds == training_data$ganhador)
test_acc <- mean(test_preds == test_data$ganhador)
# Exibir a precisão nos conjuntos de treinamento e teste
cat('Precisão nos dados de treinamento:', train_acc, '\n')
cat('Precisão nos dados de teste:', test_acc, '\n')
# Verificar se há overfitting comparando a precisão nos conjuntos de treinamento e teste
if(test_acc < train_acc){
cat('A precisão nos dados de teste é menor do que a precisão nos dados de treinamento, o que pode indicar overfitting.\n')
} else {
cat('Não há evidência de overfitting.\n')
}
# Procurando uma rede neural com acuracia acima de determinado percentual --------------------------------
z <- 0.1
while (i < 0.80) {
achar_Nn(t = 0.5, mostrar_i = F)
}
# Achar uma boa seed -------------------------------------------------------------------------------------
s <- 7688 # 10679 13/03 0.7959% acuracia 98 partidas
while ( i < 0.78) {
achar_Seed(s, hidden_n, t = 0.5, mostrar_i = F)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
