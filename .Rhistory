normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
test_data$ganhador <- as.factor(test_data$ganhador)
training_data$ganhador <- as.factor(training_data$ganhador)
# Carregando modelo e obtendo os resultados
load('prototipo_rede_neural.rda')
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5, 1, 0)
nn2 <- as.factor(nn2)
x <- caret::confusionMatrix(nn2, test_data$ganhador)
F1 <- x$byClass['F1']
x <- as.data.frame(x$table)
predictVstest <- cbind(test_data, Predict$net.result)
names(predictVstest)[32] <- 'previsao'
# Curva ROC
ROC <- roc(response = as.factor(predictVstest$ganhador),
predictor = predictVstest$previsao)
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = 'grey40', size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = '1 - Especificidade',
y = 'Sensitividade',
title = paste('Área abaixo da curva:',
round(ROC$auc, 4),
'|',
'Coeficiente de Gini:',
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = 'black', fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
# Curva ROC
ROC <- roc(response = as.factor(predictVstest$ganhador),
predictor = predictVstest$previsao)
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = 'grey40', size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = '1 - Especificidade',
y = 'Sensitividade',
title = paste('Área abaixo da curva:',
round(ROC$auc, 4),
'|',
'Coeficiente de Gini:',
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = 'black', fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
# Curva ROC
ROC <- roc(response = as.factor(predictVstest$ganhador),
predictor = predictVstest$previsao)
predicoes <- prediction(predictions = predictVstest$previsao,
labels = as.factor(predictVstest$ganhador))
predicoes <- ROCR::prediction(predictions = predictVstest$previsao,
labels = as.factor(predictVstest$ganhador))
dados_curva_roc <- performance(predicoes, measure = "sens")
sensitividade <- (performance(predicoes, measure = "sens"))@y.values[[1]]
especificidade <- (performance(predicoes, measure = "spec"))@y.values[[1]]
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = 'grey40', size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = '1 - Especificidade',
y = 'Sensitividade',
title = paste('Área abaixo da curva:',
round(ROC$auc, 4),
'|',
'Coeficiente de Gini:',
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = 'black', fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
x <- caret::confusionMatrix(nn2, test_data$ganhador)
x
F1 <- x$byClass['F1']
x <- as.data.frame(x$table)
predictVstest <- cbind(test_data, Predict$net.result)
names(predictVstest)[32] <- 'previsao'
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date('2023-02-19'), Sys.Date() - 1, by = 'day')
nomes_arquivos <- paste0('csv/catalogacao_diaria/', format(datas, '%Y-%m-%d'), '_partidas.csv')
jogos_lista <- list()
for (arquivo in nomes_arquivos) {
jogos_lista[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
jogos <- bind_rows(jogos_lista) %>% select(-X)
jogos$ganhador <- as.factor(jogos$ganhador)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
data_split <- initial_split(jogos, prop = 0.7, strata = 'ganhador')
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(30)
t <- 1 #thresholder
formula <- 'ganhador == 1 ~ .'
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(formula,
data = training_data,
hidden = hidden_n,
err.fct = 'sse',
linear.output = F,
threshold = t,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
# Achar uma boa seed -------------------------------------------------------------------------------------
s <- 1 # 10679 13/03 0.7959% acuracia 98 partidas
w <- 0.1
while ( i < 0.80) {
achar_Seed(s, hidden_n, t = 0.9)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
s <- 71905
while ( i < 0.80) {
achar_Seed(s, hidden_n, t = 0.9)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
# Matriz de confusão ---------------------------------------------------------------------------------------
jogos <- read.csv2('csv/partidas_teste.csv') %>% dplyr::select(-X)
s <- 10679
set.seed(s-1) #10679
data_split <- initial_split(jogos, prop = 0.7, strata = 'ganhador')
training_data <- training(data_split)
test_data <- testing(data_split)
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
test_data$ganhador <- as.factor(test_data$ganhador)
training_data$ganhador <- as.factor(training_data$ganhador)
# Carregando modelo e obtendo os resultados
load('prototipo_rede_neural.rda')
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>0.5, 1, 0)
nn2 <- as.factor(nn2)
x <- caret::confusionMatrix(nn2, test_data$ganhador)
F1 <- x$byClass['F1']
x <- as.data.frame(x$table)
predictVstest <- cbind(test_data, Predict$net.result)
names(predictVstest)[32] <- 'previsao'
# Curva ROC
ROC <- roc(response = as.factor(predictVstest$ganhador),
predictor = predictVstest$previsao)
predicoes <- ROCR::prediction(predictions = predictVstest$previsao,
labels = as.factor(predictVstest$ganhador))
dados_curva_roc <- performance(predicoes, measure = "sens")
sensitividade <- (performance(predicoes, measure = "sens"))@y.values[[1]]
especificidade <- (performance(predicoes, measure = "spec"))@y.values[[1]]
ggplot() +
geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1),
color = 'grey40', size = 0.2) +
geom_line(aes(x = 1 - especificidade, y = sensitividade),
color = "darkorchid", size = 2) +
labs(x = '1 - Especificidade',
y = 'Sensitividade',
title = paste('Área abaixo da curva:',
round(ROC$auc, 4),
'|',
'Coeficiente de Gini:',
round((ROC$auc[1] - 0.5) / 0.5, 4))) +
theme(panel.background = element_rect(NA),
panel.border = element_rect(color = 'black', fill = NA),
legend.text = element_text(size = 10),
legend.title = element_text(size = 10)
)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date('2023-03-14'), Sys.Date() - 1, by = 'day')
nomes_arquivos <- paste0('csv/previsao_diaria/', format(datas, '%Y-%m-%d'), '_acuracia.csv')
nomes_arquivos
acuracia[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(ROCR)
library(kableExtra)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date('2023-03-14'), Sys.Date() - 1, by = 'day')
nomes_arquivos <- paste0('csv/previsao_diaria/', format(datas, '%Y-%m-%d'), '_acuracia.csv')
acuracia <- list()
for (arquivo in nomes_arquivos) {
acuracia[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
View(acuracia)
acuracia <- bind_rows(acuracia) %>% select(-X)
acertos <- sum(acuracia$acertos)
erros <- sum(acuracia$erros)
acuracia_total <- acertos/(acertos+erros)
print(acuracia_total <- acertos/(acertos+erros))
rm(acuracia_total)
print(acuracia_total <- acertos/(acertos+erros))
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(ROCR)
library(kableExtra)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date('2023-02-19'), Sys.Date() - 1, by = 'day')
nomes_arquivos <- paste0('csv/catalogacao_diaria/', format(datas, '%Y-%m-%d'), '_partidas.csv')
jogos_lista <- list()
for (arquivo in nomes_arquivos) {
jogos_lista[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
jogos <- bind_rows(jogos_lista) %>% select(-X)
jogos$ganhador <- as.factor(jogos$ganhador)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
data_split <- initial_split(jogos, prop = 0.7, strata = 'ganhador')
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(30)
t <- 1 #thresholder
formula <- 'ganhador == 1 ~ .'
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(formula,
data = training_data,
hidden = hidden_n,
err.fct = 'sse',
linear.output = F,
threshold = t,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
# Achar uma boa seed -------------------------------------------------------------------------------------
s <- 1 # 10679 13/03 0.7959% acuracia 98 partidas
w <- 0.1
while ( i < 0.80) {
achar_Seed(s, hidden_n, t = 0.9)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
while ( i < 0.78) {
achar_Seed(s, hidden_n, t = 0.9)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(ROCR)
library(kableExtra)
library(valorant)
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(ROCR)
library(kableExtra)
library(valorant)
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(ROCR)
library(kableExtra)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date('2023-03-14'), Sys.Date() - 1, by = 'day')
nomes_arquivos <- paste0('csv/previsao_diaria/', format(datas, '%Y-%m-%d'), '_acuracia.csv')
acuracia <- list()
for (arquivo in nomes_arquivos) {
acuracia[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
acuracia <- bind_rows(acuracia) %>% select(-X)
acertos <- sum(acuracia$acertos)
erros <- sum(acuracia$erros)
print(acuracia_total <- acertos/(acertos+erros))
# Instalando pacotes (se necessário) e carregando ----------------------------------------------------------
library(devtools)
install_github('Juniorffonseca/r-pacote-valorant')
library(caret)
library(dplyr)
library(tidyr)
library(rvest)
library(rsample)
library(readr)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(nnet)
library(caret)
library(ggplot2)
library(ModelMetrics)
library(beepr)
library(purrr)
library(plotly)
library(pROC)
library(ROCR)
library(kableExtra)
library(valorant)
# Carregando partidas diarias e unindo em um df ------------------------------------------------------------
datas <- seq(as.Date('2023-02-19'), Sys.Date() - 1, by = 'day')
nomes_arquivos <- paste0('csv/catalogacao_diaria/', format(datas, '%Y-%m-%d'), '_partidas.csv')
jogos_lista <- list()
for (arquivo in nomes_arquivos) {
jogos_lista[[arquivo]] <- possibly(read.csv2, otherwise = NULL)(arquivo)
}
jogos <- bind_rows(jogos_lista) %>% select(-X)
jogos$ganhador <- as.factor(jogos$ganhador)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(1)
data_split <- initial_split(jogos, prop = 0.7, strata = 'ganhador')
training_data <- training(data_split)
test_data <- testing(data_split)
hidden_n <- c(30)
t <- 1 #thresholder
formula <- 'ganhador == 1 ~ .'
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(formula,
data = training_data,
hidden = hidden_n,
err.fct = 'sse',
linear.output = F,
threshold = t,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
# Achar uma boa seed -------------------------------------------------------------------------------------
s <- 1 # 10679 13/03 0.7959% acuracia 98 partidas
w <- 0.1
while ( i < 0.78) {
achar_Seed(s, hidden_n, t = 0.9)
s <- s + 1
w <<- ifelse(i>w, w <<- i, w <<- w)
print(w)
}
# Atualizando a seed para achar a melhor neuralnetwork ----------------------------------------------------
set.seed(s-1) #22263
data_split <- initial_split(jogos, prop = 0.7, strata = 'ganhador')
training_data <- training(data_split)
test_data <- testing(data_split)
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
Predict = compute(n, test_data)
nn2 <<- ifelse(Predict$net.result[,1]>0.5,1,0)
predictVstest <- cbind(test_data, Predict$net.result)
# Procurando uma rede neural com acuracia acima de determinado percentual --------------------------------
z <- 0.1
while (i < 0.80) {
achar_Nn(t = 0.9)
}
while (i < 0.83) {
achar_Nn(t = 0.9)
}
